#edit  Line 46 & 45
#Created By MetiNaj
# its not PREMIUM Version!
#To buy the premium version, go to the site Selfx.shop/en 

try:
	import random , os , psutil , json , pytz , aiocron , asyncio , requests
	from telethon.sync import TelegramClient , events
	from telethon import functions , utils
	from telethon.tl.custom import Dialog
	from telethon.tl import types
	from googletrans import Translator
	from gtts import gTTS
	from datetime import datetime , timedelta
except ModuleNotFoundError:
	os.system('pip install --upgrade pip && pip install -U telethon && pip install psutil && pip install asyncio && pip install aiocron && pip install pytz && pip install googletrans==4.0.0-rc1 && pip install gtts && pip install requests && clear')
	os.sys.exit('installed the required packages !')


def get(file):
	with open(file,"r") as r:
		return json.load(r)

def put(file,data):
	with open(file,"w") as w:
		json.dump(data,w)

def timeDif(get):
	match = str(datetime.strptime(get.replace('+00:00', ''), '%Y-%m-%d %H:%M:%S')).split(' ')
	date = match[0].split('-')
	time = match[1].split(':')
	delta = timedelta(
	days = int(date[2]),
	hours = int(time[0]),
	minutes = int(time[1]),
	seconds = int(time[2]),
	)
	return int(delta.total_seconds())


if not "data.json" in os.listdir():
		data = {"timename":"off","timebio":"off","timeprof":"off","bot":"on","hashtag":"off","bold":"off","italic":"off","delete":"off","code":"off","underline":"off","reverse":"off","part":"off","mention":"off","comment":"on","text":"first !","typing":"off","game":"off","voice":"off","video":"off","sticker":"off","crash":[],"enemy":[]}
		put("data.json",data)

api_id = 21598855
api_hash = 'bf9998c2b5695b1f14541b842354f47a'

session_name = 'self'

bot = TelegramClient(session_name, api_id, api_hash)

@aiocron.crontab('*/1 * * * *')
async def clock():
	js = get("data.json")
	if js['timename'] == "off" and js['timebio'] == "off" and js['timeprof'] == "off":
		pass
	ir = pytz.timezone("Asia/Tehran")
	time = datetime.now(ir).strftime("%H : %M")
	rand = {'0':'ï¼','1':'ï¼‘','2':'ï¼’','3':'ï¼“','4':'ï¼”','5':'ï¼•','6':'ï¼–','7':'ï¼—','8':'ï¼˜','9':'ï¼™',':':':',' ':' '}
	fonts = ''.join([rand[str(i)] for i in time])+str(random.choice(["ğŸŒµ","ğŸ§¸","ğŸ¥€"]))
	bio = "á´›Êœá´‡ á´‹ÉªÉ´É¢ Éªs á´›Êœá´‡ á´É´á´‡ á´¡Êœá´ Êœá´€s á´É´ÊŸÊ É¢á´á´… 78! {}".format(fonts)
	if js['timename'] == "on":
		await bot(functions.account.UpdateProfileRequest(last_name = fonts))
	if js['timebio'] == "on":
		await bot(functions.account.UpdateProfileRequest(about = bio))
	if js['timeprof'] == "on":
		if "photo" in os.listdir():
			await bot(functions.photos.UploadProfilePhotoRequest(await bot.upload_file(random.choice(os.listdir("photo")))))

@bot.on(events.NewMessage())
async def updateMessage(event):
	js = get("data.json")
	fromid = event.sender_id
	if fromid in js['enemy']:
		await event.delete()
	elif fromid in js['crash']:
		emoticons = ["ğŸ¤","ğŸ–¤","ğŸ’œ","ğŸ’™","ğŸ’š","ğŸ’›","ğŸ§¡","â¤ï¸","ğŸ¤","ğŸ’–"]
		await event.reply(random.choice(emoticons))
		await event.forward_to('me')
	elif js['comment'] == "on" and not event.fwd_from is None:
		if not event.fwd_from.saved_from_peer is None:
			await event.reply(js['text'])


@bot.on(events.NewMessage())
async def updateAction(event):
	js = get("data.json")
	for type in ["typing","game","voice","video","sticker"]:
		if js[type] == "on":
			async with bot.action(event.chat_id,type):
				await asyncio.sleep(2)

@bot.on(events.NewMessage(pattern=r'(help|Ø±Ø§Ù‡Ù†Ù…Ø§)', outgoing=True))
async def help(event):
	memoryUse = psutil.Process(os.getpid()).memory_info()[0] / 1073741824
	memoryPercent = psutil.virtual_memory()[2]
	cpuPercent = psutil.cpu_percent()
	me = await bot.get_me()
	name = me.first_name
	js = get("data.json")
	help = f"Ğ½elp Ğ¼eÉ´Ï… {name} :\n\nâŸ©â€¢â€¢â€¢ á´›Éªá´á´‡ É´á´€á´á´‡ : {js['timename']}\nâŸ©â€¢â€¢â€¢ á´›Éªá´á´‡ Ê™Éªá´ : {js['timebio']}\nâŸ©â€¢â€¢â€¢ time prof : {js['timeprof']}\nâŸ©â€¢â€¢â€¢ Ê™á´á´› É´á´á´¡ Éªs : {js['bot']}\nâŸ©â€¢â€¢â€¢ Êœá´€sÊœá´›á´€É¢ : {js['hashtag']}\nâŸ©â€¢â€¢â€¢ Ê™á´ÊŸá´… : {js['bold']}\nâŸ©â€¢â€¢â€¢ Éªá´›á´€ÊŸÉªá´„ : {js['italic']}\nâŸ©â€¢â€¢â€¢ á´…á´‡ÊŸá´‡á´›á´‡ : {js['delete']}\nâŸ©â€¢â€¢â€¢ á´„á´á´…á´‡ : {js['code']}\nâŸ©â€¢â€¢â€¢ á´œÉ´á´…á´‡Ê€ÊŸÉªÉ´á´‡ : {js['underline']}\nâŸ©â€¢â€¢â€¢ Ê€á´‡á´ á´‡Ê€sá´‡ : {js['reverse']}\nâŸ©â€¢â€¢â€¢ á´˜á´€Ê€á´› : {js['part']}\nâŸ©â€¢â€¢â€¢ á´á´‡É´á´›Éªá´É´ : {js['mention']}\nâŸ©â€¢â€¢â€¢ coĞ¼Ğ¼eÉ´Ñ‚ : {js['comment']}\nâŸ©â€¢â€¢â€¢ Ñ‚eÑ…Ñ‚ coĞ¼Ğ¼eÉ´Ñ‚ : {js['text']}\n\nâŸ©â€¢â€¢â€¢ á´›Êá´˜ÉªÉ´É¢ : {js['typing']}\nâŸ©â€¢â€¢â€¢ É¢á´€á´á´‡ : {js['game']}\nâŸ©â€¢â€¢â€¢ á´ á´Éªá´„á´‡ : {js['voice']}\nâŸ©â€¢â€¢â€¢ á´ Éªá´…á´‡á´ : {js['video']}\nâŸ©â€¢â€¢â€¢ sá´›Éªá´„á´‹á´‡Ê€ : {js['sticker']}\n\nâŸ©â€¢â€¢â€¢ .timebio (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ .timename (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ .timeprof (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ .comment (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ .commentText (Ñ‚eÑ…Ñ‚)\n\nâŸ©â€¢â€¢â€¢ hashtag (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ bold (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ italic (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ delete (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ code (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ underline (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ reverse (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ part (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ mention (oÉ´|oÒ“Ò“)\n\nâŸ©â€¢â€¢â€¢ typing (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ game (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ voice (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ video (oÉ´|oÒ“Ò“)\nâŸ©â€¢â€¢â€¢ sticker (oÉ´|oÒ“Ò“)\n\nâŸ©â€¢â€¢â€¢ .addenemy (Î¹d)\nâŸ©â€¢â€¢â€¢ .delenemy (Î¹d)\nâŸ©â€¢â€¢â€¢ listenemy\nâŸ©â€¢â€¢â€¢ .addcrash (Î¹d)\nâŸ©â€¢â€¢â€¢ .delcrash (Î¹d)\nâŸ©â€¢â€¢â€¢ listcrash\n\nâŸ©â€¢â€¢â€¢ .reaction (Ñ‚eÑ…Ñ‚)\nâŸ©â€¢â€¢â€¢ heart\nâŸ©â€¢â€¢â€¢ tagall\nâŸ©â€¢â€¢â€¢ tagadmins\nâŸ©â€¢â€¢â€¢ .check (Ñ‚eÑ…Ñ‚)\nâŸ©â€¢â€¢â€¢ download\n\nâŸ©â€¢â€¢â€¢ info (Î¹d)(reply)\nâŸ©â€¢â€¢â€¢ status\nâŸ©â€¢â€¢â€¢ .clean (Î¹É´Ñ‚)\n\nâ€¢ á´á´‡á´á´Ê€Ê á´œsá´‡á´… : {memoryUse}\nâ€¢ á´á´‡á´á´Ê€Ê : {memoryPercent} %\nâ€¢ á´„á´˜á´œ : {cpuPercent} %\nâ€¢ á´„Ê€ : @MetiFo !"
	await bot.send_message(event.chat_id,help,reply_to = event.message.id)
	results = await bot.inline_query('like','ï¼¤ï¼¯ ï¼¹ï¼¯ï¼µ ï¼¬ï¼©ï¼«ï¼¥ ï¼­ï¼¹ ï¼²ï¼¯ï¼¢ï¼¯ï¼´ ? ')
	await results[0].click(event.chat_id)


@bot.on(events.NewMessage(pattern=r'\.dice (1|2|3|4|5|6)', outgoing=True))
async def dice(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	await event.delete()
	send = await bot.send_file(event.chat_id, types.InputMediaDice('ğŸ²'))
	while(send.media.value != int(input_str)):
		await bot.delete_messages(event.chat_id,send.id)
		send = await bot.send_file(event.chat_id, types.InputMediaDice('ğŸ²'))

@bot.on(events.NewMessage(pattern=r'\.reaction (.*)', outgoing=True))
async def reaction(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	if input_str in "love":
		emoticons = ["ğŸ¤","ğŸ–¤","ğŸ’œ","ğŸ’™","ğŸ’š","ğŸ’›","ğŸ§¡","â¤ï¸","ğŸ¤","ğŸ’–"]
	elif input_str in "oclock":
		emoticons = ["ğŸ•","ğŸ•‘","ğŸ•’","ğŸ•“","ğŸ•”","ğŸ••","ğŸ•–","ğŸ•—","ğŸ•˜","ğŸ•™","ğŸ•š","ğŸ•›","ğŸ•œ","ğŸ•","ğŸ•","ğŸ•Ÿ","ğŸ• ","ğŸ•¡","ğŸ•¢","ğŸ•£","ğŸ•¤","ğŸ•¥","ğŸ•¦","ğŸ•§"]
	elif input_str in "star":
		emoticons = ["ğŸ’¥","âš¡ï¸","âœ¨","ğŸŒŸ","â­ï¸","ğŸ’«"]
	elif input_str in "snow":
		emoticons = ["â„ï¸","â˜ƒï¸","â›„ï¸"]		
	for i in range(10):
		await asyncio.sleep(0.5)
		await event.edit(random.choice(emoticons))

@bot.on(events.NewMessage(pattern=r'(heart|Ù‚Ù„Ø¨)', outgoing=True))
async def heart(event):
	if event.fwd_from:
		return
	for x in range(1,4):
		for i in range(1,11):
			txt = "â£ " + str(x) + " â¦" * i + " | " + str(10 * i) + "%"
			await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.clean (.*)', outgoing=True))
async def clean(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	message_id = event.message.id
	for i in range(int(input_str)):
		await bot.delete_messages(event.chat_id,message_id)
		message_id -= 1
	await bot.send_message(event.chat_id,f"{input_str} Ğ¼eÑ•Ñ•Î±É¢eÑ• were deleÑ‚e . . . !")

@bot.on(events.NewMessage(pattern=r'\.addcrash (.*)', outgoing=True))
async def addcrash(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['crash']:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´¡á´€s ÉªÉ´ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		js["crash"].append(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) É´á´á´¡ ÉªÉ´ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.delcrash (.*)', outgoing=True))
async def delcrash(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['crash']:
		js["crash"].remove(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) Éªs É´á´á´› ÉªÉ´ á´›Êœá´‡ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(listcrash|Ù„ÛŒØ³Øª Ú©Ø±Ø§Ø´)', outgoing=True))
async def listcrash(event):
	txt = "crÎ±Ñ•Ğ½ ÊŸÉªsá´› :\n"
	js = get("data.json")
	for i in js['crash']:
		lo += "\nâ€¢ [{}](tg://user?id={})".format(i,i)
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.addenemy (.*)', outgoing=True))
async def addenemy(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['enemy']:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´¡á´€s ÉªÉ´ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		js["enemy"].append(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) É´á´á´¡ ÉªÉ´ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.delenemy (.*)', outgoing=True))
async def delenemy(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['enemy']:
		js["enemy"].remove(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) Éªs É´á´á´› ÉªÉ´ á´›Êœá´‡ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(listenemy|Ù„ÛŒØ³Øª Ø§Ù†Ù…ÛŒ)', outgoing=True))
async def listenemy(event):
	txt = "á´‡É´á´‡á´Ê ÊŸÉªsá´› :\n"
	js = get("data.json")
	for i in js['enemy']:
		lo += "\nâ€¢ [{}](tg://user?id={})".format(i,i)
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.timename (on|off)', outgoing=True))
async def timename(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["timename"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ á´›Éªá´á´‡ É´á´€á´á´‡ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'\.timeprof (on|off)', outgoing=True))
async def timeprof(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["timeprof"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ á´›Éªá´á´‡ prof É´á´á´¡ Éªs {input_str}")


@bot.on(events.NewMessage(pattern=r'\.timebio (on|off)', outgoing=True))
async def timebio(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["timebio"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ á´›Éªá´á´‡ Ê™Éªá´ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'\.comment (on|off)', outgoing=True))
async def comment(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["comment"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ coĞ¼Ğ¼eÉ´Ñ‚ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'\.commentText (.*)', outgoing=True))
async def comment(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["text"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ coĞ¼Ğ¼eÉ´Ñ‚ Ñ‚eÑ…Ñ‚ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'(tagall|ØªÚ¯)', outgoing=True , func=lambda e: e.is_group))
async def tagall(event):
	if event.fwd_from:
		return
	mentions = "âœ… Ø¢Ø®Ø±ÛŒÙ† Ø§ÙØ±Ø§Ø¯ Ø¢Ù†Ù„Ø§ÛŒÙ† Ú¯Ø±ÙˆÙ‡"
	chat = await event.get_input_chat()
	async for x in bot.iter_participants(chat, 100):
		mentions += f" \n [{x.first_name}](tg://user?id={x.id})"
	await event.reply(mentions)
	await event.delete()
	
@bot.on(events.NewMessage(pattern=r'(tagadmins|ØªÚ¯ Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§)', outgoing=True , func=lambda e: e.is_group))
async def tagadmins(event):
	if event.fwd_from:
		return
	mentions = "âš¡ï¸ ØªÚ¯ Ú©Ø±Ø¯Ù† Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§"
	chat = await event.get_input_chat()
	async for x in bot.iter_participants(chat, filter = types.ChannelParticipantsAdmins):
		mentions += f" \n [{x.first_name}](tg://user?id={x.id})"
	await event.reply(mentions)
	await event.delete()

@bot.on(events.NewMessage(pattern=r'\.check (.*)', outgoing=True))
async def reaction(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	link = "https://api-bot.site/check/Check.php?phone={}".format(input_str)
	req = requests.get(link)
	txt = "Ok {} | status : {} | Results : {}".format(input_str,req.json()['status'],req.json()['Results'])
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(info|Ø§Ø·Ù„Ø§Ø¹Ø§Øª)', outgoing=True))
async def info(event):
	if event.fwd_from:
		return
	if event.is_reply:
		getMessage = await event.get_reply_message()
		get_id = getMessage.sender.id
	else:
		match = event.raw_text.split(' ')
		if len(match) == 2:
			get_id = int(match[1])
		else:
			get_id = event.chat_id
	full = await bot(functions.users.GetFullUserRequest(get_id))
	first_name = full.user.first_name
	last_name = full.user.last_name
	username = full.user.username
	about = full.about
	phone = full.user.phone
	ir = pytz.timezone("Asia/Tehran")
	time = datetime.now(ir).strftime("á´›Éªá´á´‡ | %H:%M:%S")
	txt = "Ï…Ñ•er Î¹d : {}\nÒ“Î¹rÑ•Ñ‚ É´Î±Ğ¼e : {}\nlÎ±Ñ•Ñ‚ É´Î±Ğ¼e : {}\nÏ…Ñ•erÉ´Î±Ğ¼e : {}\npĞ½oÉ´e : {}\nĞ²Î¹o : {}\n{}".format(get_id,first_name,last_name,username,phone,about,time)
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(status|ÙˆØ¶Ø¹ÛŒØª)', outgoing=True))
async def status(event):
	if event.fwd_from:
		return
	private_chats = 0
	bots = 0
	groups = 0
	broadcast_channels = 0
	admin_in_groups = 0
	creator_in_groups = 0
	admin_in_broadcast_channels = 0
	creator_in_channels = 0
	unread_mentions = 0
	unread = 0
	largest_group_member_count = 0
	largest_group_with_admin = 0
	dialog: Dialog
	async for dialog in bot.iter_dialogs():
		entity = dialog.entity
		if isinstance(entity,types.Channel):
			if entity.broadcast:
				broadcast_channels += 1
				if entity.creator or entity.admin_rights:
					admin_in_broadcast_channels += 1
				if entity.creator:
					creator_in_channels += 1
			elif entity.megagroup:
				groups += 1
				if entity.creator or entity.admin_rights:
					admin_in_groups += 1
				if entity.creator:
					creator_in_groups += 1
		elif isinstance(entity,types.User):
			private_chats += 1
			if entity.bot:
				bots += 1
		elif isinstance(entity,types.Chat):
			groups += 1
			if entity.creator or entity.admin_rights:
				admin_in_groups += 1
			if entity.creator:
				creator_in_groups += 1
		unread_mentions += dialog.unread_mentions_count
		unread += dialog.unread_count
	txt = f"Ñ•Ñ‚Î±Ñ‚Ï…Ñ• !"
	txt += f"\ná´˜Ê€Éªá´ á´€á´›á´‡ á´„Êœá´€á´›s : {private_chats}"
	txt += f"\nÊ™á´á´›s : {bots}"
	txt += f"\nÉ¢Ê€á´á´œá´˜s : {groups}"
	txt += f"\nÊ™Ê€á´á´€á´…á´„á´€sá´› á´„Êœá´€É´É´á´‡ÊŸs : {broadcast_channels}"
	txt += f"\ná´€á´…á´ÉªÉ´ ÉªÉ´ É¢Ê€á´á´œá´˜s : {admin_in_groups}"
	txt += f"\ná´„Ê€á´‡á´€á´›á´Ê€ ÉªÉ´ É¢Ê€á´á´œá´˜s : {creator_in_groups}"
	txt += f"\ná´€á´…á´ÉªÉ´ ÉªÉ´ Ê™Ê€á´á´€á´…á´„á´€sá´› á´„Êœá´€É´É´á´‡ÊŸs : {admin_in_broadcast_channels}"
	txt += f"\ná´„Ê€á´‡á´€á´›á´Ê€ ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸs : {creator_in_channels}"
	txt += f"\ná´œÉ´Ê€á´‡á´€á´… á´á´‡É´á´›Éªá´É´s : {unread_mentions}"
	txt += f"\ná´œÉ´Ê€á´‡á´€á´… : {unread}"
	txt += f"\nÊŸá´€Ê€É¢á´‡sá´› É¢Ê€á´á´œá´˜ á´á´‡á´Ê™á´‡Ê€ á´„á´á´œÉ´á´› : {largest_group_member_count}"
	txt += f"\nÊŸá´€Ê€É¢á´‡sá´› É¢Ê€á´á´œá´˜ á´¡Éªá´›Êœ á´€á´…á´ÉªÉ´ : {largest_group_with_admin}"
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(sessions|Ù†Ø´Ø³Øª Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„)', outgoing=True))
async def session(event):
	if event.fwd_from:
		return
	result = await bot(functions.account.GetAuthorizationsRequest())
	txt = f"sá´‡ssÉªá´É´s :\n\n"
	for i in result.authorizations:
		txt += f"Êœá´€sÊœ : {i.hash}\ná´…á´‡á´ Éªá´„á´‡ á´á´á´…á´‡ÊŸ : {i.device_model}\ná´˜ÊŸá´€á´›Ò“á´Ê€á´ : {i.platform}\nsÊsá´›á´‡á´ á´ á´‡Ê€sÉªá´É´ : {i.system_version}\ná´€á´˜Éª Éªá´… : {i.api_id}\ná´€á´˜á´˜ É´á´€á´á´‡ : {i.app_name}\ná´€á´˜á´˜ á´ á´‡Ê€sÉªá´É´ : {i.app_version}\ná´…á´€á´›á´‡ á´„Ê€á´‡á´€á´›á´‡á´… : {i.date_created}\ná´…á´€á´›á´‡ á´€á´„á´›Éªá´ á´‡ : {i.date_active}\nÉªá´˜ : {i.ip}\ná´„á´á´œÉ´á´›Ê€Ê : {i.country}\nâ”„â”…â”ˆâ”‰â”…â”‰â”ˆâ”…â”„â”„â”…â”ˆâ”‰â”…â”‰â”ˆâ”…â”„â”„â”…â”ˆâ”‰â”…â”‰â”ˆâ”…â”„\n"
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(translate|Ù…ØªØ±Ø¬Ù…)', outgoing=True , func=lambda e: e.is_reply))
async def translate(event):
	if event.fwd_from:
		return
	match = event.raw_text.split(' ')
	if len(match) == 2:
		lan = str(match[1])
	else:
		lan = "fa"
	getMessage = await event.get_reply_message()
	message = getMessage.raw_text
	try:
		translate = Translator().translate(message,lan)
		src = translate.src
		dest = translate.dest
		text = translate.text
		await event.edit(f"á´›Ê€á´€É´sÊŸá´€á´›á´‡á´… Ò“Ê€á´á´ {src} á´›á´ {dest}\n\ná´›Ê€á´€É´sÊŸá´€á´›á´‡á´… á´›á´‡xá´› : {text}")
		voice = gTTS(text = message , lang = src , slow = True)
		voice.save('file.mp3')
		await bot.send_file(event.chat_id, 'file.mp3' , voice_note = True , reply_to = event.message.id)
		os.remove('file.mp3')
	except Exception as e:
		await bot.send_message('me', f"ï¼¥ï¼²ï¼²ï¼¯ï¼² :\n\n{e}")

@bot.on(events.NewMessage(pattern=r'(download|Ø¯Ø§Ù†Ù„ÙˆØ¯)', outgoing=True , func=lambda e: e.is_reply))
async def download(event):
	if event.fwd_from:
		return
	try:
		message = await event.get_reply_message()
		download = await bot.download_media(message)
		await bot.send_message('me','@MetiFo :)', file = d)
		os.remove(d)
	except Exception as e:
		await bot.send_message('me', f"ï¼¥ï¼²ï¼²ï¼¯ï¼² :\n\n{e}")

@bot.on(events.NewMessage(outgoing=True))
async def mode(event):
	if event.fwd_from:
		return
	js = get("data.json")
	text = event.raw_text
	if js['hashtag'] == "on":
		new = text.replace(" ","_")
		await event.edit(f"#{new}")
	elif js['bold'] == "on":
		await event.edit(f"<b>{text}</b>", parse_mode = "HTML")
	elif js['italic'] == "on":
		await event.edit(f"<i>{text}</i>", parse_mode = "HTML")
	elif js['delete'] == "on":
		await event.edit(f"<del>{text}</del>", parse_mode = "HTML")
	elif js['code'] == "on":
		await event.edit(f"<code>{text}</code>", parse_mode = "HTML")
	elif js['underline'] == "on":
		await event.edit(f"<u>{text}</u>", parse_mode = "HTML")
	elif js['reverse'] == "on":
		await event.edit(text[::-1], parse_mode = "HTML")
	elif js['part'] == "on":
		if len(text) > 1:
			new = ""
			for add in text:
				new += add
				if add != " ":
					await event.edit(new, parse_mode = "HTML")
	elif js['mention'] == "on":
		if event.is_reply:
			try:
				getMessage = await event.get_reply_message()
				get_id = getMessage.sender.id
				await event.edit(f"<a href ='tg://openmessage?user_id={get_id}'>{text}</a>", parse_mode = "HTML")
			except Exception as e:
				await bot.send_message('me', f"ï¼¥ï¼²ï¼²ï¼¯ï¼² :\n\n{e}")

@bot.on(events.NewMessage(pattern=r'(hashtag|bold|italic|delete|code|underline|reverse|part|mention) (on|off)', outgoing=True))
async def editMode(event):
	if event.fwd_from:
		return
	match = event.raw_text.split(' ')
	js = get("data.json")
	js[match[0]] = str(match[1])
	put("data.json",js)
	mode = match[0].translate(match[0].maketrans("qwertyuiopasdfghjklzxcvbnm","Ç«á´¡á´‡Ê€á´›Êá´œÉªá´á´˜á´€sá´…Ò“É¢Êœá´Šá´‹ÊŸá´¢xá´„á´ Ê™É´á´"))
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ {mode} á´á´á´…á´‡ É´á´á´¡ Éªs {match[1]}")

@bot.on(events.NewMessage(pattern=r'(typing|game|voice|video|sticker) (on|off)', outgoing=True))
async def editAction(event):
	if event.fwd_from:
		return
	match = event.raw_text.split(' ')
	js = get("data.json")
	js[match[0]] = str(match[1])
	put("data.json",js)
	action = match[0].translate(match[0].maketrans("qwertyuiopasdfghjklzxcvbnm","Ç«á´¡á´‡Ê€á´›Êá´œÉªá´á´˜á´€sá´…Ò“É¢Êœá´Šá´‹ÊŸá´¢xá´„á´ Ê™É´á´"))
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ {action} Î±cÑ‚Î¹oÉ´ É´á´á´¡ Éªs {match[1]}")

bot.start()
clock.start()
bot.run_until_disconnected()
asyncio.get_event_loop().run_forever()= event.message.id)
	results = await bot.inline_query('like','ï¼¤ï¼¯ ï¼¹ï¼¯ï¼µ ï¼¬ï¼©ï¼«ï¼¥ ï¼­ï¼¹ ï¼²ï¼¯ï¼¢ï¼¯ï¼´ ? ')
	await results[0].click(event.chat_id)


@bot.on(events.NewMessage(pattern=r'\.dice (1|2|3|4|5|6)', outgoing=True))
async def dice(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	await event.delete()
	send = await bot.send_file(event.chat_id, types.InputMediaDice('ğŸ²'))
	while(send.media.value != int(input_str)):
		await bot.delete_messages(event.chat_id,send.id)
		send = await bot.send_file(event.chat_id, types.InputMediaDice('ğŸ²'))

@bot.on(events.NewMessage(pattern=r'\.reaction (.*)', outgoing=True))
async def reaction(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	if input_str in "love":
		emoticons = ["ğŸ¤","ğŸ–¤","ğŸ’œ","ğŸ’™","ğŸ’š","ğŸ’›","ğŸ§¡","â¤ï¸","ğŸ¤","ğŸ’–"]
	elif input_str in "oclock":
		emoticons = ["ğŸ•","ğŸ•‘","ğŸ•’","ğŸ•“","ğŸ•”","ğŸ••","ğŸ•–","ğŸ•—","ğŸ•˜","ğŸ•™","ğŸ•š","ğŸ•›","ğŸ•œ","ğŸ•","ğŸ•","ğŸ•Ÿ","ğŸ• ","ğŸ•¡","ğŸ•¢","ğŸ•£","ğŸ•¤","ğŸ•¥","ğŸ•¦","ğŸ•§"]
	elif input_str in "star":
		emoticons = ["ğŸ’¥","âš¡ï¸","âœ¨","ğŸŒŸ","â­ï¸","ğŸ’«"]
	elif input_str in "snow":
		emoticons = ["â„ï¸","â˜ƒï¸","â›„ï¸"]		
	for i in range(10):
		await asyncio.sleep(0.5)
		await event.edit(random.choice(emoticons))

@bot.on(events.NewMessage(pattern=r'(heart|Ù‚Ù„Ø¨)', outgoing=True))
async def heart(event):
	if event.fwd_from:
		return
	for x in range(1,4):
		for i in range(1,11):
			txt = "â£ " + str(x) + " â¦" * i + " | " + str(10 * i) + "%"
			await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.clean (.*)', outgoing=True))
async def clean(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	message_id = event.message.id
	for i in range(int(input_str)):
		await bot.delete_messages(event.chat_id,message_id)
		message_id -= 1
	await bot.send_message(event.chat_id,f"{input_str} Ğ¼eÑ•Ñ•Î±É¢eÑ• were deleÑ‚e . . . !")

@bot.on(events.NewMessage(pattern=r'\.addcrash (.*)', outgoing=True))
async def addcrash(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['crash']:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´¡á´€s ÉªÉ´ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		js["crash"].append(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) É´á´á´¡ ÉªÉ´ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.delcrash (.*)', outgoing=True))
async def delcrash(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['crash']:
		js["crash"].remove(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) Éªs É´á´á´› ÉªÉ´ á´›Êœá´‡ crÎ±Ñ•Ğ½ ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(listcrash|Ù„ÛŒØ³Øª Ú©Ø±Ø§Ø´)', outgoing=True))
async def listcrash(event):
	txt = "crÎ±Ñ•Ğ½ ÊŸÉªsá´› :\n"
	js = get("data.json")
	for i in js['crash']:
		lo += "\nâ€¢ [{}](tg://user?id={})".format(i,i)
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.addenemy (.*)', outgoing=True))
async def addenemy(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['enemy']:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´¡á´€s ÉªÉ´ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		js["enemy"].append(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) É´á´á´¡ ÉªÉ´ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.delenemy (.*)', outgoing=True))
async def delenemy(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	if int(input_str) in js['enemy']:
		js["enemy"].remove(int(input_str))
		put("data.json",js)
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)
	else:
		txt = "â€¢ [á´œsá´‡Ê€](tg://user?id={}) Éªs É´á´á´› ÉªÉ´ á´›Êœá´‡ á´‡É´á´‡á´Ê ÊŸÉªsá´› !".format(int(input_str))
		await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(listenemy|Ù„ÛŒØ³Øª Ø§Ù†Ù…ÛŒ)', outgoing=True))
async def listenemy(event):
	txt = "á´‡É´á´‡á´Ê ÊŸÉªsá´› :\n"
	js = get("data.json")
	for i in js['enemy']:
		lo += "\nâ€¢ [{}](tg://user?id={})".format(i,i)
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'\.timename (on|off)', outgoing=True))
async def timename(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["timename"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ á´›Éªá´á´‡ É´á´€á´á´‡ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'\.timeprof (on|off)', outgoing=True))
async def timeprof(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["timeprof"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ á´›Éªá´á´‡ prof É´á´á´¡ Éªs {input_str}")


@bot.on(events.NewMessage(pattern=r'\.timebio (on|off)', outgoing=True))
async def timebio(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["timebio"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ á´›Éªá´á´‡ Ê™Éªá´ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'\.comment (on|off)', outgoing=True))
async def comment(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["comment"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ coĞ¼Ğ¼eÉ´Ñ‚ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'\.commentText (.*)', outgoing=True))
async def comment(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	js = get("data.json")
	js["text"] = str(input_str)
	put("data.json",js)
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ coĞ¼Ğ¼eÉ´Ñ‚ Ñ‚eÑ…Ñ‚ É´á´á´¡ Éªs {input_str}")

@bot.on(events.NewMessage(pattern=r'(tagall|ØªÚ¯)', outgoing=True , func=lambda e: e.is_group))
async def tagall(event):
	if event.fwd_from:
		return
	mentions = "âœ… Ø¢Ø®Ø±ÛŒÙ† Ø§ÙØ±Ø§Ø¯ Ø¢Ù†Ù„Ø§ÛŒÙ† Ú¯Ø±ÙˆÙ‡"
	chat = await event.get_input_chat()
	async for x in bot.iter_participants(chat, 100):
		mentions += f" \n [{x.first_name}](tg://user?id={x.id})"
	await event.reply(mentions)
	await event.delete()
	
@bot.on(events.NewMessage(pattern=r'(tagadmins|ØªÚ¯ Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§)', outgoing=True , func=lambda e: e.is_group))
async def tagadmins(event):
	if event.fwd_from:
		return
	mentions = "âš¡ï¸ ØªÚ¯ Ú©Ø±Ø¯Ù† Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§"
	chat = await event.get_input_chat()
	async for x in bot.iter_participants(chat, filter = types.ChannelParticipantsAdmins):
		mentions += f" \n [{x.first_name}](tg://user?id={x.id})"
	await event.reply(mentions)
	await event.delete()

@bot.on(events.NewMessage(pattern=r'\.check (.*)', outgoing=True))
async def reaction(event):
	if event.fwd_from:
		return
	input_str = event.pattern_match.group(1)
	link = "https://api-bot.site/check/Check.php?phone={}".format(input_str)
	req = requests.get(link)
	txt = "Ok {} | status : {} | Results : {}".format(input_str,req.json()['status'],req.json()['Results'])
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(info|Ø§Ø·Ù„Ø§Ø¹Ø§Øª)', outgoing=True))
async def info(event):
	if event.fwd_from:
		return
	if event.is_reply:
		getMessage = await event.get_reply_message()
		get_id = getMessage.sender.id
	else:
		match = event.raw_text.split(' ')
		if len(match) == 2:
			get_id = int(match[1])
		else:
			get_id = event.chat_id
	full = await bot(functions.users.GetFullUserRequest(get_id))
	first_name = full.user.first_name
	last_name = full.user.last_name
	username = full.user.username
	about = full.about
	phone = full.user.phone
	ir = pytz.timezone("Asia/Tehran")
	time = datetime.now(ir).strftime("á´›Éªá´á´‡ | %H:%M:%S")
	txt = "Ï…Ñ•er Î¹d : {}\nÒ“Î¹rÑ•Ñ‚ É´Î±Ğ¼e : {}\nlÎ±Ñ•Ñ‚ É´Î±Ğ¼e : {}\nÏ…Ñ•erÉ´Î±Ğ¼e : {}\npĞ½oÉ´e : {}\nĞ²Î¹o : {}\n{}".format(get_id,first_name,last_name,username,phone,about,time)
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(status|ÙˆØ¶Ø¹ÛŒØª)', outgoing=True))
async def status(event):
	if event.fwd_from:
		return
	private_chats = 0
	bots = 0
	groups = 0
	broadcast_channels = 0
	admin_in_groups = 0
	creator_in_groups = 0
	admin_in_broadcast_channels = 0
	creator_in_channels = 0
	unread_mentions = 0
	unread = 0
	largest_group_member_count = 0
	largest_group_with_admin = 0
	dialog: Dialog
	async for dialog in bot.iter_dialogs():
		entity = dialog.entity
		if isinstance(entity,types.Channel):
			if entity.broadcast:
				broadcast_channels += 1
				if entity.creator or entity.admin_rights:
					admin_in_broadcast_channels += 1
				if entity.creator:
					creator_in_channels += 1
			elif entity.megagroup:
				groups += 1
				if entity.creator or entity.admin_rights:
					admin_in_groups += 1
				if entity.creator:
					creator_in_groups += 1
		elif isinstance(entity,types.User):
			private_chats += 1
			if entity.bot:
				bots += 1
		elif isinstance(entity,types.Chat):
			groups += 1
			if entity.creator or entity.admin_rights:
				admin_in_groups += 1
			if entity.creator:
				creator_in_groups += 1
		unread_mentions += dialog.unread_mentions_count
		unread += dialog.unread_count
	txt = f"Ñ•Ñ‚Î±Ñ‚Ï…Ñ• !"
	txt += f"\ná´˜Ê€Éªá´ á´€á´›á´‡ á´„Êœá´€á´›s : {private_chats}"
	txt += f"\nÊ™á´á´›s : {bots}"
	txt += f"\nÉ¢Ê€á´á´œá´˜s : {groups}"
	txt += f"\nÊ™Ê€á´á´€á´…á´„á´€sá´› á´„Êœá´€É´É´á´‡ÊŸs : {broadcast_channels}"
	txt += f"\ná´€á´…á´ÉªÉ´ ÉªÉ´ É¢Ê€á´á´œá´˜s : {admin_in_groups}"
	txt += f"\ná´„Ê€á´‡á´€á´›á´Ê€ ÉªÉ´ É¢Ê€á´á´œá´˜s : {creator_in_groups}"
	txt += f"\ná´€á´…á´ÉªÉ´ ÉªÉ´ Ê™Ê€á´á´€á´…á´„á´€sá´› á´„Êœá´€É´É´á´‡ÊŸs : {admin_in_broadcast_channels}"
	txt += f"\ná´„Ê€á´‡á´€á´›á´Ê€ ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸs : {creator_in_channels}"
	txt += f"\ná´œÉ´Ê€á´‡á´€á´… á´á´‡É´á´›Éªá´É´s : {unread_mentions}"
	txt += f"\ná´œÉ´Ê€á´‡á´€á´… : {unread}"
	txt += f"\nÊŸá´€Ê€É¢á´‡sá´› É¢Ê€á´á´œá´˜ á´á´‡á´Ê™á´‡Ê€ á´„á´á´œÉ´á´› : {largest_group_member_count}"
	txt += f"\nÊŸá´€Ê€É¢á´‡sá´› É¢Ê€á´á´œá´˜ á´¡Éªá´›Êœ á´€á´…á´ÉªÉ´ : {largest_group_with_admin}"
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(sessions|Ù†Ø´Ø³Øª Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„)', outgoing=True))
async def session(event):
	if event.fwd_from:
		return
	result = await bot(functions.account.GetAuthorizationsRequest())
	txt = f"sá´‡ssÉªá´É´s :\n\n"
	for i in result.authorizations:
		txt += f"Êœá´€sÊœ : {i.hash}\ná´…á´‡á´ Éªá´„á´‡ á´á´á´…á´‡ÊŸ : {i.device_model}\ná´˜ÊŸá´€á´›Ò“á´Ê€á´ : {i.platform}\nsÊsá´›á´‡á´ á´ á´‡Ê€sÉªá´É´ : {i.system_version}\ná´€á´˜Éª Éªá´… : {i.api_id}\ná´€á´˜á´˜ É´á´€á´á´‡ : {i.app_name}\ná´€á´˜á´˜ á´ á´‡Ê€sÉªá´É´ : {i.app_version}\ná´…á´€á´›á´‡ á´„Ê€á´‡á´€á´›á´‡á´… : {i.date_created}\ná´…á´€á´›á´‡ á´€á´„á´›Éªá´ á´‡ : {i.date_active}\nÉªá´˜ : {i.ip}\ná´„á´á´œÉ´á´›Ê€Ê : {i.country}\nâ”„â”…â”ˆâ”‰â”…â”‰â”ˆâ”…â”„â”„â”…â”ˆâ”‰â”…â”‰â”ˆâ”…â”„â”„â”…â”ˆâ”‰â”…â”‰â”ˆâ”…â”„\n"
	await event.edit(txt)

@bot.on(events.NewMessage(pattern=r'(translate|Ù…ØªØ±Ø¬Ù…)', outgoing=True , func=lambda e: e.is_reply))
async def translate(event):
	if event.fwd_from:
		return
	match = event.raw_text.split(' ')
	if len(match) == 2:
		lan = str(match[1])
	else:
		lan = "fa"
	getMessage = await event.get_reply_message()
	message = getMessage.raw_text
	try:
		translate = Translator().translate(message,lan)
		src = translate.src
		dest = translate.dest
		text = translate.text
		await event.edit(f"á´›Ê€á´€É´sÊŸá´€á´›á´‡á´… Ò“Ê€á´á´ {src} á´›á´ {dest}\n\ná´›Ê€á´€É´sÊŸá´€á´›á´‡á´… á´›á´‡xá´› : {text}")
		voice = gTTS(text = message , lang = src , slow = True)
		voice.save('file.mp3')
		await bot.send_file(event.chat_id, 'file.mp3' , voice_note = True , reply_to = event.message.id)
		os.remove('file.mp3')
	except Exception as e:
		await bot.send_message('me', f"ï¼¥ï¼²ï¼²ï¼¯ï¼² :\n\n{e}")

@bot.on(events.NewMessage(pattern=r'(download|Ø¯Ø§Ù†Ù„ÙˆØ¯)', outgoing=True , func=lambda e: e.is_reply))
async def download(event):
	if event.fwd_from:
		return
	try:
		message = await event.get_reply_message()
		download = await bot.download_media(message)
		await bot.send_message('me','@MetiFo :)', file = d)
		os.remove(d)
	except Exception as e:
		await bot.send_message('me', f"ï¼¥ï¼²ï¼²ï¼¯ï¼² :\n\n{e}")

@bot.on(events.NewMessage(outgoing=True))
async def mode(event):
	if event.fwd_from:
		return
	js = get("data.json")
	text = event.raw_text
	if js['hashtag'] == "on":
		new = text.replace(" ","_")
		await event.edit(f"#{new}")
	elif js['bold'] == "on":
		await event.edit(f"<b>{text}</b>", parse_mode = "HTML")
	elif js['italic'] == "on":
		await event.edit(f"<i>{text}</i>", parse_mode = "HTML")
	elif js['delete'] == "on":
		await event.edit(f"<del>{text}</del>", parse_mode = "HTML")
	elif js['code'] == "on":
		await event.edit(f"<code>{text}</code>", parse_mode = "HTML")
	elif js['underline'] == "on":
		await event.edit(f"<u>{text}</u>", parse_mode = "HTML")
	elif js['reverse'] == "on":
		await event.edit(text[::-1], parse_mode = "HTML")
	elif js['part'] == "on":
		if len(text) > 1:
			new = ""
			for add in text:
				new += add
				if add != " ":
					await event.edit(new, parse_mode = "HTML")
	elif js['mention'] == "on":
		if event.is_reply:
			try:
				getMessage = await event.get_reply_message()
				get_id = getMessage.sender.id
				await event.edit(f"<a href ='tg://openmessage?user_id={get_id}'>{text}</a>", parse_mode = "HTML")
			except Exception as e:
				await bot.send_message('me', f"ï¼¥ï¼²ï¼²ï¼¯ï¼² :\n\n{e}")

@bot.on(events.NewMessage(pattern=r'(hashtag|bold|italic|delete|code|underline|reverse|part|mention) (on|off)', outgoing=True))
async def editMode(event):
	if event.fwd_from:
		return
	match = event.raw_text.split(' ')
	js = get("data.json")
	js[match[0]] = str(match[1])
	put("data.json",js)
	mode = match[0].translate(match[0].maketrans("qwertyuiopasdfghjklzxcvbnm","Ç«á´¡á´‡Ê€á´›Êá´œÉªá´á´˜á´€sá´…Ò“É¢Êœá´Šá´‹ÊŸá´¢xá´„á´ Ê™É´á´"))
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ {mode} á´á´á´…á´‡ É´á´á´¡ Éªs {match[1]}")

@bot.on(events.NewMessage(pattern=r'(typing|game|voice|video|sticker) (on|off)', outgoing=True))
async def editAction(event):
	if event.fwd_from:
		return
	match = event.raw_text.split(' ')
	js = get("data.json")
	js[match[0]] = str(match[1])
	put("data.json",js)
	action = match[0].translate(match[0].maketrans("qwertyuiopasdfghjklzxcvbnm","Ç«á´¡á´‡Ê€á´›Êá´œÉªá´á´˜á´€sá´…Ò“É¢Êœá´Šá´‹ÊŸá´¢xá´„á´ Ê™É´á´"))
	await event.edit(f"âŸ©â€¢â€¢â€¢ á´›Êœá´‡ {action} Î±cÑ‚Î¹oÉ´ É´á´á´¡ Éªs {match[1]}")

bot.start()
clock.start()
bot.run_until_disconnected()
asyncio.get_event_loop().run_forever()
